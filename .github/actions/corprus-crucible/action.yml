name: 'Corprus Crucible'
description: 'Strogg manufacturing system for Rust binaries - builds, signs, and scans releases'

inputs:
  binary_name:
    description: 'Name of the binary (without platform suffix)'
    required: true
  include_files:
    description: 'Additional files to include in archives (comma-separated)'
    required: false
    default: 'Readme.md,LICENSE'
  vt_api_key:
    description: 'VirusTotal API key (REQUIRED)'
    required: true
  github_token:
    description: 'GitHub Token (REQUIRED)'
    required: true

outputs:
  release_name:
    description: 'Name of the release (tag or development)'
    value: ${{ steps.cleanup.outputs.release_name }}

runs:
  using: composite
  steps:
    # Validate required VirusTotal API key
    - name: Validate VirusTotal API Key
      shell: bash
      run: |
        if [ -z "${{ inputs.vt_api_key }}" ]; then
          echo "::error::VirusTotal API key is required!"
          echo "Please provide vt_api_key input to this action"
          exit 1
        else
          echo "✅ VirusTotal API key is set"
        fi

    - name: Ensure fresh development release exists
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          exit 0
        fi

        sleep $((RANDOM % 15))

        WORKFLOW_ID="${{ github.run_id }}"

        for i in {1..12}; do  # 12 attempts * 5s = 60s max
          echo "Check attempt $i/12..."

          if RELEASE_INFO=$(gh release view development --json body 2>/dev/null); then
            RELEASE_BODY=$(echo "$RELEASE_INFO" | jq -r '.body // ""')

            if echo "$RELEASE_BODY" | grep -q "Generated by workflow run: $WORKFLOW_ID"; then
              echo "✓ Found fresh release created by this workflow"
              exit 0
            else
              echo "Found old release from different workflow"

              # Only try to replace on attempts 1, 6, 11 (every 5th attempt)
              if (( i % 5 == 1 )); then
                echo "Attempting to replace old release..."

                # Delete old release
                gh release delete development --yes 2>/dev/null || echo "Delete failed (maybe already gone)"
                sleep 2
                gh api -X DELETE repos/${{ github.repository }}/git/refs/tags/development 2>/dev/null || echo "There was a tag here. It's gone now."
                sleep 2

                # Create new release with our workflow ID
                echo "Creating new release for this workflow..."
                if gh release create development --prerelease --generate-notes; then
                  # Append our workflow marker to the generated notes
                  gh release edit development --notes-file <(gh release view development --json body --jq '.body' && echo -e "\n\n---\nGenerated by workflow run: $WORKFLOW_ID")
                  echo "✓ Created and tagged new release"
                  exit 0
                else
                  echo "Create failed (maybe another job succeeded), will retry..."
                fi
              fi
            fi
          else
            echo "No release found at all"

            # Only try to create on attempts 1, 6, 11
            if (( i % 5 == 1 )); then
              echo "Attempting to create new release..."
              if gh release create development --prerelease --generate-notes; then
                # Append our workflow marker
                gh release edit development --notes-file <(gh release view development --json body --jq '.body' && echo -e "\n\n---\nGenerated by workflow run: $WORKFLOW_ID")
                echo "✓ Created new release"
                exit 0
              else
                echo "Create failed (maybe another job succeeded), will retry..."
              fi
            fi
          fi

          # Wait before next check (except on last iteration)
          if [ $i -lt 12 ]; then
            echo "Waiting 5 seconds..."
            sleep 5
          fi
        done

        echo "::error ::Could not secure fresh development release within timeout"
        exit 1

    - name: Setup Release Environment
      id: cleanup
      shell: bash
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          echo "release_name=${{ github.ref_name }}" >> $GITHUB_OUTPUT
        else
          echo "release_name=development" >> $GITHUB_OUTPUT
        fi

    - name: Determine Binary Suffix
      id: os_check
      shell: bash
      run: |
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          echo "suffix=.exe" >> $GITHUB_OUTPUT
          echo "Binary suffix: '.exe' (Windows detected)"
        else
          echo "suffix=" >> $GITHUB_OUTPUT
          echo "Binary suffix: '' (${{ runner.os }} detected)"
        fi

    - name: Determine Build Context
      id: context
      shell: bash
      run: |
        # Auto-detect: if binary_name is a directory, build there
        if [ -d "${{ inputs.binary_name }}" ]; then
          BUILD_DIR="${{ inputs.binary_name }}"
        else
          BUILD_DIR="."
        fi

        echo "build_dir=$BUILD_DIR" >> $GITHUB_OUTPUT

    # Build steps
    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable

    - name: ⚡ Cache Dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-${{ runner.arch }}-cargo-${{ hashFiles('**/Cargo.lock') }}

    - name: Build Release
      shell: bash
      run: cargo build --release --manifest-path ${{ steps.context.outputs.build_dir }}/Cargo.toml

    - name: Install Cosign
      uses: sigstore/cosign-installer@main

    - name: Sign Binary
      shell: bash
      run: |
        BINARY_NAME="${{ inputs.binary_name }}${{ steps.os_check.outputs.suffix }}"
        cosign sign-blob -y "${{ steps.context.outputs.build_dir }}/target/release/$BINARY_NAME" \
          --bundle "${{ inputs.binary_name }}-${{ runner.os }}-${{ runner.arch }}.bundle"

    - name: Create Archive
      shell: bash
      run: |
        BINARY_NAME="${{ inputs.binary_name }}${{ steps.os_check.outputs.suffix }}"
        ARCHIVE_NAME="${{ inputs.binary_name}}-${{ runner.os }}-${{ runner.arch }}.zip"
        
        7z a -tzip "$ARCHIVE_NAME" -r "${{ inputs.binary_name }}-${{ runner.os }}-${{ runner.arch }}.bundle" \
          "./${{ steps.context.outputs.build_dir }}/target/release/$BINARY_NAME"
        
        IFS=',' read -ra FILES <<< "${{ inputs.include_files }}"
        for file in "${FILES[@]}"; do
          if [ -f "${{ steps.context.outputs.build_dir }}/$file" ]; then
            7z u -tzip -r "$ARCHIVE_NAME" "./${{ steps.context.outputs.build_dir }}/$file"
          fi
        done

    - name: VirusTotal Scan
      id: vt_scan
      uses: crazy-max/ghaction-virustotal@v4
      with:
        update_release_body: true
        vt_api_key: ${{ inputs.vt_api_key }}
        files: ${{ steps.context.outputs.build_dir }}/target/release/${{ inputs.binary_name }}${{ steps.os_check.outputs.suffix }}

    - name: Format VirusTotal Links
      id: format_vt_links
      shell: bash
      run: |
        # Extract just the filename for display
        FILENAME="${{ inputs.binary_name }}-${{ runner.os }}-${{ runner.arch }}"

        # The vt_scan outputs.analysis is like "filename=https://virustotal.com/..."
        # Parse it to create markdown links
        if [ -n "${{ steps.vt_scan.outputs.analysis }}" ]; then
          # Convert "filename=url,filename2=url2" to markdown
          ANALYSIS_TEXT=""
          IFS=',' read -ra ENTRIES <<< "${{ steps.vt_scan.outputs.analysis }}"

          for entry in "${ENTRIES[@]}"; do
            IFS='=' read -r file url <<< "$entry"
            ANALYSIS_TEXT="${ANALYSIS_TEXT}- [${FILENAME} on VirusTotal](${url})"$'\n'
          done

          echo "vt_analysis=${ANALYSIS_TEXT}" >> $GITHUB_OUTPUT
        else
          echo "vt_analysis=" >> $GITHUB_OUTPUT
        fi

    - name: Upload to GitHub Release
      uses: softprops/action-gh-release@v2
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      with:
        tag_name: ${{ steps.cleanup.outputs.release_name }}
        prerelease: ${{ github.ref_type != 'tag' }}
        files: ${{ inputs.binary_name }}-${{ runner.os }}-${{ runner.arch }}.zip
        append_body: true
        body: |
          ${{ steps.format_vt_links.outputs.vt_analysis }}

